{"ast":null,"code":"import { gsap, ScrollTrigger } from \"../gsap\";\nconst $html = document.documentElement;\nconst IS_MOBILE = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === \"MacIntel\" && navigator.maxTouchPoints > 1;\nexport default {\n  name: \"AppBase\",\n  components: {},\n  data: () => ({\n    navIsOpen: false\n  }),\n  computed: {\n    className() {\n      let classname = \"l-wrapper\";\n      /*if (this.currentPageName) {\n        classname += ` p-${this.currentPageName}`;\n      }*/\n      // Add nav state\n\n      if (this.navIsOpen) {\n        classname += \" nav-is-open\";\n      }\n\n      return classname;\n    }\n\n  },\n  methods: {\n    // this is the helper function that sets it all up. Pass in the content <div> and then the wrapping viewport <div> (can be the elements or selector text). It also sets the default \"scroller\" to the content so you don't have to do that on all your ScrollTriggers.\n    smoothScroll() {\n      const smoothness = 1;\n      gsap.set(this.$refs.scroll, {\n        overflow: \"hidden\",\n        position: \"fixed\",\n        height: \"100%\",\n        width: \"100%\",\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      });\n      gsap.set(this.$refs.scrollInner, {\n        overflow: \"visible\",\n        width: \"100%\"\n      }); //https://greensock.com/docs/v3/GSAP/gsap.getProperty()\n      //Reusable getter function\n      //If you omit the property parameter, gsap.getProperty() will return a getter function that you can reuse to grab properties of that target object:\n\n      const getProp = gsap.getProperty(this.$refs.scrollInner); //Think of a quickSetter like an optimized function tied to a particular target's (or set of targets') property,\n      // where it directly pipes data to it and skips convenience tasks in a normal gsap.set()\n\n      const setProp = gsap.quickSetter(this.$refs.scrollInner, \"y\", \"px\");\n      const setScroll = ScrollTrigger.getScrollFunc(window);\n\n      const removeScroll = () => this.$refs.scrollInner.style.overflow = \"visible\";\n\n      const killScrub = trigger => {\n        let scrub = trigger.getTween();\n        scrub && scrub.kill();\n        trigger.animation.progress(trigger.progress);\n      };\n\n      let isProxyScrolling;\n\n      const refreshSmoothScroll = () => {\n        this.scrollHeight = this.$refs.scrollInner.clientHeight;\n        this.$refs.scrollInner.style.overflow = \"visible\";\n        $html.style.height = this.scrollHeight + \"px\";\n      };\n\n      refreshSmoothScroll();\n      ScrollTrigger.addEventListener(\"refreshInit\", refreshSmoothScroll.bind(this));\n      ScrollTrigger.addEventListener(\"refresh\", () => {\n        removeScroll(); //requestAnimationFrame(removeScroll);\n      });\n      ScrollTrigger.defaults({\n        scroller: this.$refs.scrollInner\n      });\n      ScrollTrigger.scrollerProxy(this.$refs.scrollInner, {\n        scrollTop(value) {\n          if (arguments.length) {\n            isProxyScrolling = true; // otherwise, if snapping was applied (or anything that attempted to SET the scroll proxy's scroll position), we'd set the scroll here which would then (on the next tick) update the content tween/ScrollTrigger which would try to smoothly animate to that new value, thus the scrub tween would impede the progress. So we use this flag to respond accordingly in the ScrollTrigger's onUpdate and effectively force the scrub to its end immediately.\n\n            setProp(-value);\n            setScroll(value);\n            return;\n          }\n\n          return -getProp(\"y\");\n        },\n\n        getBoundingClientRect() {\n          return {\n            top: 0,\n            left: 0,\n            width: window.innerWidth,\n            height: window.innerHeight\n          };\n        }\n\n      });\n      return ScrollTrigger.create({\n        animation: gsap.fromTo(this.$refs.scrollInner, {\n          y: 0\n        }, {\n          y: () => document.documentElement.clientHeight - this.scrollHeight,\n          ease: \"none\",\n          onUpdate: ScrollTrigger.update\n        }),\n        scroller: window,\n        invalidateOnRefresh: true,\n        start: 0,\n        end: () => this.scrollHeight - document.documentElement.clientHeight,\n        scrub: smoothness,\n        onUpdate: self => {\n          if (isProxyScrolling) {\n            killScrub(self);\n            isProxyScrolling = false;\n          }\n        } //onRefresh: killScrub, // when the screen resizes, we just want the animation to immediately go to the appropriate spot rather than animating there, so basically kill the scrub.\n\n      });\n    }\n\n  },\n\n  mounted() {\n    console.log(\"APP BASE MOUNTED\");\n    this.scroller = IS_MOBILE ? false : this.smoothScroll(); // Watch body height change\n\n    let timeout;\n    const resizeObserver = new ResizeObserver(() => {\n      console.log(\"RESIZE OBSERVER\");\n\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      timeout = setTimeout(() => {\n        ScrollTrigger.refresh();\n      }, 200);\n    });\n    resizeObserver.observe(this.$refs.main);\n  }\n\n};","map":{"version":3,"mappings":"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","names":["gsap","ScrollTrigger","$html","document","documentElement","IS_MOBILE","test","navigator","userAgent","platform","maxTouchPoints","name","components","data","navIsOpen","computed","className","classname","methods","smoothScroll","smoothness","set","$refs","scroll","overflow","position","height","width","top","left","right","bottom","scrollInner","getProp","getProperty","setProp","quickSetter","setScroll","getScrollFunc","window","removeScroll","style","killScrub","trigger","scrub","getTween","kill","animation","progress","isProxyScrolling","refreshSmoothScroll","scrollHeight","clientHeight","addEventListener","bind","defaults","scroller","scrollerProxy","scrollTop","value","arguments","length","getBoundingClientRect","innerWidth","innerHeight","create","fromTo","y","ease","onUpdate","update","invalidateOnRefresh","start","end","self","mounted","console","log","timeout","resizeObserver","ResizeObserver","clearTimeout","setTimeout","refresh","observe","main"],"sourceRoot":"","sources":["/home/maxime/personal_repos/sweet-portfolio/src/layout/AppBase.vue"],"sourcesContent":["<template>\n  <div :class=\"className\" ref=\"wrapper\">\n    <div ref=\"scroll\" class=\"o-scroll\">\n      <div ref=\"scrollInner\">\n        <main id=\"main\" ref=\"main\" class=\"l-main\">\n          <router-view v-slot=\"{ Component }\">\n            <transition name=\"fade\" mode=\"out-in\">\n              <component :is=\"Component\" />\n            </transition>\n          </router-view>\n        </main>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { gsap, ScrollTrigger } from \"../gsap\";\n\nconst $html = document.documentElement;\nconst IS_MOBILE =\n  /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    navigator.userAgent\n  ) ||\n  (navigator.platform === \"MacIntel\" && navigator.maxTouchPoints > 1);\n\nexport default {\n  name: \"AppBase\",\n  components: {},\n  data: () => ({\n    navIsOpen: false,\n  }),\n  computed: {\n    className() {\n      let classname = \"l-wrapper\";\n\n      /*if (this.currentPageName) {\n        classname += ` p-${this.currentPageName}`;\n      }*/\n\n      // Add nav state\n      if (this.navIsOpen) {\n        classname += \" nav-is-open\";\n      }\n\n      return classname;\n    },\n  },\n  methods: {\n    // this is the helper function that sets it all up. Pass in the content <div> and then the wrapping viewport <div> (can be the elements or selector text). It also sets the default \"scroller\" to the content so you don't have to do that on all your ScrollTriggers.\n    smoothScroll() {\n      const smoothness = 1;\n\n      gsap.set(this.$refs.scroll, {\n        overflow: \"hidden\",\n        position: \"fixed\",\n        height: \"100%\",\n        width: \"100%\",\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n      });\n\n      gsap.set(this.$refs.scrollInner, { overflow: \"visible\", width: \"100%\" });\n\n      //https://greensock.com/docs/v3/GSAP/gsap.getProperty()\n      //Reusable getter function\n      //If you omit the property parameter, gsap.getProperty() will return a getter function that you can reuse to grab properties of that target object:\n\n      const getProp = gsap.getProperty(this.$refs.scrollInner);\n\n      //Think of a quickSetter like an optimized function tied to a particular target's (or set of targets') property,\n      // where it directly pipes data to it and skips convenience tasks in a normal gsap.set()\n\n      const setProp = gsap.quickSetter(this.$refs.scrollInner, \"y\", \"px\");\n\n      const setScroll = ScrollTrigger.getScrollFunc(window);\n\n      const removeScroll = () =>\n        (this.$refs.scrollInner.style.overflow = \"visible\");\n\n      const killScrub = (trigger) => {\n        let scrub = trigger.getTween();\n        scrub && scrub.kill();\n        trigger.animation.progress(trigger.progress);\n      };\n\n      let isProxyScrolling;\n\n      const refreshSmoothScroll = () => {\n        this.scrollHeight = this.$refs.scrollInner.clientHeight;\n        this.$refs.scrollInner.style.overflow = \"visible\";\n        $html.style.height = this.scrollHeight + \"px\";\n      };\n\n      refreshSmoothScroll();\n\n      ScrollTrigger.addEventListener(\n        \"refreshInit\",\n        refreshSmoothScroll.bind(this)\n      );\n      ScrollTrigger.addEventListener(\"refresh\", () => {\n        removeScroll();\n        //requestAnimationFrame(removeScroll);\n      });\n      ScrollTrigger.defaults({ scroller: this.$refs.scrollInner });\n\n      ScrollTrigger.scrollerProxy(this.$refs.scrollInner, {\n        scrollTop(value) {\n          if (arguments.length) {\n            isProxyScrolling = true; // otherwise, if snapping was applied (or anything that attempted to SET the scroll proxy's scroll position), we'd set the scroll here which would then (on the next tick) update the content tween/ScrollTrigger which would try to smoothly animate to that new value, thus the scrub tween would impede the progress. So we use this flag to respond accordingly in the ScrollTrigger's onUpdate and effectively force the scrub to its end immediately.\n            setProp(-value);\n            setScroll(value);\n            return;\n          }\n          return -getProp(\"y\");\n        },\n        getBoundingClientRect() {\n          return {\n            top: 0,\n            left: 0,\n            width: window.innerWidth,\n            height: window.innerHeight,\n          };\n        },\n      });\n\n      return ScrollTrigger.create({\n        animation: gsap.fromTo(\n          this.$refs.scrollInner,\n          { y: 0 },\n          {\n            y: () => document.documentElement.clientHeight - this.scrollHeight,\n            ease: \"none\",\n            onUpdate: ScrollTrigger.update,\n          }\n        ),\n        scroller: window,\n        invalidateOnRefresh: true,\n        start: 0,\n        end: () => this.scrollHeight - document.documentElement.clientHeight,\n        scrub: smoothness,\n        onUpdate: (self) => {\n          if (isProxyScrolling) {\n            killScrub(self);\n            isProxyScrolling = false;\n          }\n        },\n        //onRefresh: killScrub, // when the screen resizes, we just want the animation to immediately go to the appropriate spot rather than animating there, so basically kill the scrub.\n      });\n    },\n  },\n\n  mounted() {\n    console.log(\"APP BASE MOUNTED\");\n    this.scroller = IS_MOBILE ? false : this.smoothScroll();\n\n    // Watch body height change\n    let timeout;\n    const resizeObserver = new ResizeObserver(() => {\n      console.log(\"RESIZE OBSERVER\");\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      timeout = setTimeout(() => {\n        ScrollTrigger.refresh();\n      }, 200);\n    });\n\n    resizeObserver.observe(this.$refs.main);\n  },\n};\n</script>\n\n<style lang=\"scss\">\n.l-wrapper {\n  html.is-ready & {\n    transition: color 0.4s cubic-bezier(0.3, 1, 0.7, 1);\n  }\n}\n\n.o-scroll {\n  html.is-ready & {\n    transition: background-color 0.4s cubic-bezier(0.3, 1, 0.7, 1);\n  }\n}\n\n.l-main {\n  min-height: vh(100);\n  opacity: 1;\n  transform: translate(0, vh(-20));\n  transition: opacity 0.6s cubic-bezier(0.3, 1, 0.7, 1),\n    transform 0.6s cubic-bezier(0.3, 1, 0.7, 1);\n\n  html.is-loading & {\n    transform: translate(0, vh(20));\n    transition: opacity 0.8s cubic-bezier(0.3, 1, 0.7, 1),\n      transform 0.8s cubic-bezier(0.3, 1, 0.7, 1);\n  }\n\n  html.is-ready & {\n    opacity: 1;\n    transform: translate(0);\n  }\n}\n</style>\n"]},"metadata":{},"sourceType":"module"}
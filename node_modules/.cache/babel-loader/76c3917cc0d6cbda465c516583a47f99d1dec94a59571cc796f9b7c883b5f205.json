{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport p5 from \"p5\";\nimport Orb from \"../helpers/Orb\";\nimport { onMounted } from \"@vue/runtime-core\";\nexport default {\n  name: \"SweetBackground\",\n  setup() {\n    onMounted(() => {\n      const sketch = s => {\n        let w = window.innerWidth;\n        let h = window.innerHeight;\n\n        //test\n        let cols = 50;\n        let rows = 50;\n        let cellWidth = w / cols;\n        let cellHeight = h / rows;\n        let grid = Array.from(Array(rows), () => new Array(cols));\n        //test\n\n        let orbs = [];\n        s.setup = () => {\n          s.createCanvas(w, h);\n          s.noStroke();\n          orbs = initOrbs();\n        };\n        s.draw = () => {\n          s.background(0);\n          for (const orb of orbs) {\n            orb.move(s);\n            //orb.render(s);\n          }\n\n          updateGrid();\n          renderGrid();\n          //test\n\n          //console.log(\"grid\", grid);\n          s.noLoop();\n          //test\n        };\n\n        function renderGrid() {\n          for (let x = 0; (x + 1) * cellWidth < w; x++) {\n            for (let y = 0; (y + 1) * cellHeight < h; y++) {\n              //s.stroke(200, 0, 200);\n              s.fill(200, 0, 200, grid[x][y] * 0.1);\n              s.rect(x, y, x * cellWidth, y * cellHeight);\n            }\n          }\n        }\n        function updateGrid() {\n          grid = Array.from(Array(rows), () => new Array(cols));\n          for (let x = 0; (x + 1) * cellWidth < w; x++) {\n            for (let y = 0; (y + 1) * cellHeight < h; y++) {\n              for (const orb of orbs) {\n                if (orb.x - orb.radius < x * cellWidth && orb.x + orb.radius > (x + 1) * cellWidth && orb.y - orb.radius < y * cellHeight && orb.y + orb.radius > (y + 1) * cellHeight) {\n                  //console.log(\"hello\", grid);\n                  grid[x][y] = grid[x][y] ? grid[x][y] + 1 : 1;\n                }\n              }\n            }\n          }\n        }\n        function collisionCercleRectangle(orb, rect) {\n          // Trouver le point le plus proche du cercle dans le rectangle\n          var closestX = clamp(orb.x, rect.x, rect.x + rect.width);\n          var closestY = clamp(orb.y, rect.y, rect.y + rect.height);\n\n          // Calculer la distance entre le cercle et le point le plus proche\n          var distanceX = orb.x - closestX;\n          var distanceY = orb.y - closestY;\n          var distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n          // Vérifier si la distance est inférieure ou égale au rayon du cercle\n          return distance <= orb.radius;\n        }\n\n        // Fonction utilitaire pour limiter une valeur entre deux bornes\n        function clamp(value, min, max) {\n          return Math.min(Math.max(value, min), max);\n        }\n        function initOrbs() {\n          const orbsArray = [];\n          let xPosInWidthPct = 0.7;\n          let yPosInHeightPct = 0.7;\n          let maxDistPct = 0.3;\n          for (let i = 0; i < 10; i++) {\n            const orb = new Orb(xPosInWidthPct, yPosInHeightPct, maxDistPct, s.color(\"#ff000040\"));\n            orbsArray.push(orb);\n          }\n          xPosInWidthPct = 0.3;\n          yPosInHeightPct = 0.3;\n          for (let i = 0; i < 10; i++) {\n            const orb = new Orb(xPosInWidthPct, yPosInHeightPct, maxDistPct, s.color(\"#0000ff40\"));\n            orbsArray.push(orb);\n          }\n          console.log(\"orbsArray\", orbsArray);\n          return orbsArray;\n        }\n        window.onresize = function () {\n          // assigns new values for width and height variables\n          w = window.innerWidth;\n          h = window.innerHeight;\n          cellWidth = w / cols;\n          cellHeight = h / rows;\n          s.resizeCanvas(w, h);\n          initOrbs();\n        };\n      };\n      new p5(sketch, \"orb-sketch\");\n    });\n  }\n};","map":{"version":3,"names":["p5","Orb","onMounted","name","setup","sketch","s","w","window","innerWidth","h","innerHeight","cols","rows","cellWidth","cellHeight","grid","Array","from","orbs","createCanvas","noStroke","initOrbs","draw","background","orb","move","updateGrid","renderGrid","noLoop","x","y","fill","rect","radius","collisionCercleRectangle","closestX","clamp","width","closestY","height","distanceX","distanceY","distance","Math","sqrt","value","min","max","orbsArray","xPosInWidthPct","yPosInHeightPct","maxDistPct","i","color","push","console","log","onresize","resizeCanvas"],"sources":["/Users/maximeconceicao/personal_repos/sweet-portfolio/src/components/SweetBackground.vue"],"sourcesContent":["<template>\n  <!-- Canvas -->\n\n  <div id=\"orb-sketch\"></div>\n  <div class=\"blur\"></div>\n  <div class=\"noise\"></div>\n</template>\n\n<script>\nimport p5 from \"p5\";\nimport Orb from \"../helpers/Orb\";\nimport { onMounted } from \"@vue/runtime-core\";\n\nexport default {\n  name: \"SweetBackground\",\n  setup() {\n    onMounted(() => {\n      const sketch = (s) => {\n        let w = window.innerWidth;\n        let h = window.innerHeight;\n\n        //test\n        let cols = 50;\n        let rows = 50;\n        let cellWidth = w / cols;\n        let cellHeight = h / rows;\n        let grid = Array.from(Array(rows), () => new Array(cols));\n        //test\n\n        let orbs = [];\n\n        s.setup = () => {\n          s.createCanvas(w, h);\n          s.noStroke();\n\n          orbs = initOrbs();\n        };\n\n        s.draw = () => {\n          s.background(0);\n          for (const orb of orbs) {\n            orb.move(s);\n            //orb.render(s);\n          }\n          updateGrid();\n          renderGrid();\n          //test\n\n          //console.log(\"grid\", grid);\n          s.noLoop();\n          //test\n        };\n\n        function renderGrid() {\n          for (let x = 0; (x + 1) * cellWidth < w; x++) {\n            for (let y = 0; (y + 1) * cellHeight < h; y++) {\n              //s.stroke(200, 0, 200);\n              s.fill(200, 0, 200, grid[x][y] * 0.1);\n              s.rect(x, y, x * cellWidth, y * cellHeight);\n            }\n          }\n        }\n\n        function updateGrid() {\n          grid = Array.from(Array(rows), () => new Array(cols));\n          for (let x = 0; (x + 1) * cellWidth < w; x++) {\n            for (let y = 0; (y + 1) * cellHeight < h; y++) {\n              for (const orb of orbs) {\n                if (\n                  orb.x - orb.radius < x * cellWidth &&\n                  orb.x + orb.radius > (x + 1) * cellWidth &&\n                  orb.y - orb.radius < y * cellHeight &&\n                  orb.y + orb.radius > (y + 1) * cellHeight\n                ) {\n                  //console.log(\"hello\", grid);\n                  grid[x][y] = grid[x][y] ? grid[x][y] + 1 : 1;\n                }\n              }\n            }\n          }\n        }\n\n        function collisionCercleRectangle(orb, rect) {\n          // Trouver le point le plus proche du cercle dans le rectangle\n          var closestX = clamp(orb.x, rect.x, rect.x + rect.width);\n          var closestY = clamp(orb.y, rect.y, rect.y + rect.height);\n\n          // Calculer la distance entre le cercle et le point le plus proche\n          var distanceX = orb.x - closestX;\n          var distanceY = orb.y - closestY;\n          var distance = Math.sqrt(\n            distanceX * distanceX + distanceY * distanceY\n          );\n\n          // Vérifier si la distance est inférieure ou égale au rayon du cercle\n          return distance <= orb.radius;\n        }\n\n        // Fonction utilitaire pour limiter une valeur entre deux bornes\n        function clamp(value, min, max) {\n          return Math.min(Math.max(value, min), max);\n        }\n\n        function initOrbs() {\n          const orbsArray = [];\n          let xPosInWidthPct = 0.7;\n          let yPosInHeightPct = 0.7;\n          let maxDistPct = 0.3;\n\n          for (let i = 0; i < 10; i++) {\n            const orb = new Orb(\n              xPosInWidthPct,\n              yPosInHeightPct,\n              maxDistPct,\n              s.color(\"#ff000040\")\n            );\n            orbsArray.push(orb);\n          }\n\n          xPosInWidthPct = 0.3;\n          yPosInHeightPct = 0.3;\n\n          for (let i = 0; i < 10; i++) {\n            const orb = new Orb(\n              xPosInWidthPct,\n              yPosInHeightPct,\n              maxDistPct,\n              s.color(\"#0000ff40\")\n            );\n            orbsArray.push(orb);\n          }\n          console.log(\"orbsArray\", orbsArray);\n          return orbsArray;\n        }\n\n        window.onresize = function () {\n          // assigns new values for width and height variables\n          w = window.innerWidth;\n          h = window.innerHeight;\n          cellWidth = w / cols;\n          cellHeight = h / rows;\n          s.resizeCanvas(w, h);\n          initOrbs();\n        };\n      };\n\n      new p5(sketch, \"orb-sketch\");\n    });\n  },\n};\n</script>\n\n<style>\n@supports ((-webkit-backdrop-filter: none) or (backdrop-filter: none)) {\n  #orb-sketch {\n    position: fixed;\n  }\n  .blur {\n    display: none;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 0;\n    background: rgba(170, 196, 200, 0.1);\n    backdrop-filter: saturate(180%) blur(3rem);\n  }\n  .noise {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 0;\n    background-image: url(\"../assets/noise.png\");\n    background-size: auto;\n    background-repeat: repeat;\n    mix-blend-mode: overlay;\n    opacity: 0.2;\n  }\n}\n</style>\n"],"mappings":";AASA,OAAOA,EAAC,MAAO,IAAI;AACnB,OAAOC,GAAE,MAAO,gBAAgB;AAChC,SAASC,SAAQ,QAAS,mBAAmB;AAE7C,eAAe;EACbC,IAAI,EAAE,iBAAiB;EACvBC,KAAKA,CAAA,EAAG;IACNF,SAAS,CAAC,MAAM;MACd,MAAMG,MAAK,GAAKC,CAAC,IAAK;QACpB,IAAIC,CAAA,GAAIC,MAAM,CAACC,UAAU;QACzB,IAAIC,CAAA,GAAIF,MAAM,CAACG,WAAW;;QAE1B;QACA,IAAIC,IAAG,GAAI,EAAE;QACb,IAAIC,IAAG,GAAI,EAAE;QACb,IAAIC,SAAQ,GAAIP,CAAA,GAAIK,IAAI;QACxB,IAAIG,UAAS,GAAIL,CAAA,GAAIG,IAAI;QACzB,IAAIG,IAAG,GAAIC,KAAK,CAACC,IAAI,CAACD,KAAK,CAACJ,IAAI,CAAC,EAAE,MAAM,IAAII,KAAK,CAACL,IAAI,CAAC,CAAC;QACzD;;QAEA,IAAIO,IAAG,GAAI,EAAE;QAEbb,CAAC,CAACF,KAAI,GAAI,MAAM;UACdE,CAAC,CAACc,YAAY,CAACb,CAAC,EAAEG,CAAC,CAAC;UACpBJ,CAAC,CAACe,QAAQ,CAAC,CAAC;UAEZF,IAAG,GAAIG,QAAQ,CAAC,CAAC;QACnB,CAAC;QAEDhB,CAAC,CAACiB,IAAG,GAAI,MAAM;UACbjB,CAAC,CAACkB,UAAU,CAAC,CAAC,CAAC;UACf,KAAK,MAAMC,GAAE,IAAKN,IAAI,EAAE;YACtBM,GAAG,CAACC,IAAI,CAACpB,CAAC,CAAC;YACX;UACF;;UACAqB,UAAU,CAAC,CAAC;UACZC,UAAU,CAAC,CAAC;UACZ;;UAEA;UACAtB,CAAC,CAACuB,MAAM,CAAC,CAAC;UACV;QACF,CAAC;;QAED,SAASD,UAAUA,CAAA,EAAG;UACpB,KAAK,IAAIE,CAAA,GAAI,CAAC,EAAE,CAACA,CAAA,GAAI,CAAC,IAAIhB,SAAQ,GAAIP,CAAC,EAAEuB,CAAC,EAAE,EAAE;YAC5C,KAAK,IAAIC,CAAA,GAAI,CAAC,EAAE,CAACA,CAAA,GAAI,CAAC,IAAIhB,UAAS,GAAIL,CAAC,EAAEqB,CAAC,EAAE,EAAE;cAC7C;cACAzB,CAAC,CAAC0B,IAAI,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAEhB,IAAI,CAACc,CAAC,CAAC,CAACC,CAAC,IAAI,GAAG,CAAC;cACrCzB,CAAC,CAAC2B,IAAI,CAACH,CAAC,EAAEC,CAAC,EAAED,CAAA,GAAIhB,SAAS,EAAEiB,CAAA,GAAIhB,UAAU,CAAC;YAC7C;UACF;QACF;QAEA,SAASY,UAAUA,CAAA,EAAG;UACpBX,IAAG,GAAIC,KAAK,CAACC,IAAI,CAACD,KAAK,CAACJ,IAAI,CAAC,EAAE,MAAM,IAAII,KAAK,CAACL,IAAI,CAAC,CAAC;UACrD,KAAK,IAAIkB,CAAA,GAAI,CAAC,EAAE,CAACA,CAAA,GAAI,CAAC,IAAIhB,SAAQ,GAAIP,CAAC,EAAEuB,CAAC,EAAE,EAAE;YAC5C,KAAK,IAAIC,CAAA,GAAI,CAAC,EAAE,CAACA,CAAA,GAAI,CAAC,IAAIhB,UAAS,GAAIL,CAAC,EAAEqB,CAAC,EAAE,EAAE;cAC7C,KAAK,MAAMN,GAAE,IAAKN,IAAI,EAAE;gBACtB,IACEM,GAAG,CAACK,CAAA,GAAIL,GAAG,CAACS,MAAK,GAAIJ,CAAA,GAAIhB,SAAQ,IACjCW,GAAG,CAACK,CAAA,GAAIL,GAAG,CAACS,MAAK,GAAI,CAACJ,CAAA,GAAI,CAAC,IAAIhB,SAAQ,IACvCW,GAAG,CAACM,CAAA,GAAIN,GAAG,CAACS,MAAK,GAAIH,CAAA,GAAIhB,UAAS,IAClCU,GAAG,CAACM,CAAA,GAAIN,GAAG,CAACS,MAAK,GAAI,CAACH,CAAA,GAAI,CAAC,IAAIhB,UAAS,EACxC;kBACA;kBACAC,IAAI,CAACc,CAAC,CAAC,CAACC,CAAC,IAAIf,IAAI,CAACc,CAAC,CAAC,CAACC,CAAC,IAAIf,IAAI,CAACc,CAAC,CAAC,CAACC,CAAC,IAAI,IAAI,CAAC;gBAC9C;cACF;YACF;UACF;QACF;QAEA,SAASI,wBAAwBA,CAACV,GAAG,EAAEQ,IAAI,EAAE;UAC3C;UACA,IAAIG,QAAO,GAAIC,KAAK,CAACZ,GAAG,CAACK,CAAC,EAAEG,IAAI,CAACH,CAAC,EAAEG,IAAI,CAACH,CAAA,GAAIG,IAAI,CAACK,KAAK,CAAC;UACxD,IAAIC,QAAO,GAAIF,KAAK,CAACZ,GAAG,CAACM,CAAC,EAAEE,IAAI,CAACF,CAAC,EAAEE,IAAI,CAACF,CAAA,GAAIE,IAAI,CAACO,MAAM,CAAC;;UAEzD;UACA,IAAIC,SAAQ,GAAIhB,GAAG,CAACK,CAAA,GAAIM,QAAQ;UAChC,IAAIM,SAAQ,GAAIjB,GAAG,CAACM,CAAA,GAAIQ,QAAQ;UAChC,IAAII,QAAO,GAAIC,IAAI,CAACC,IAAI,CACtBJ,SAAQ,GAAIA,SAAQ,GAAIC,SAAQ,GAAIA,SACtC,CAAC;;UAED;UACA,OAAOC,QAAO,IAAKlB,GAAG,CAACS,MAAM;QAC/B;;QAEA;QACA,SAASG,KAAKA,CAACS,KAAK,EAAEC,GAAG,EAAEC,GAAG,EAAE;UAC9B,OAAOJ,IAAI,CAACG,GAAG,CAACH,IAAI,CAACI,GAAG,CAACF,KAAK,EAAEC,GAAG,CAAC,EAAEC,GAAG,CAAC;QAC5C;QAEA,SAAS1B,QAAQA,CAAA,EAAG;UAClB,MAAM2B,SAAQ,GAAI,EAAE;UACpB,IAAIC,cAAa,GAAI,GAAG;UACxB,IAAIC,eAAc,GAAI,GAAG;UACzB,IAAIC,UAAS,GAAI,GAAG;UAEpB,KAAK,IAAIC,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAI,EAAE,EAAEA,CAAC,EAAE,EAAE;YAC3B,MAAM5B,GAAE,GAAI,IAAIxB,GAAG,CACjBiD,cAAc,EACdC,eAAe,EACfC,UAAU,EACV9C,CAAC,CAACgD,KAAK,CAAC,WAAW,CACrB,CAAC;YACDL,SAAS,CAACM,IAAI,CAAC9B,GAAG,CAAC;UACrB;UAEAyB,cAAa,GAAI,GAAG;UACpBC,eAAc,GAAI,GAAG;UAErB,KAAK,IAAIE,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAI,EAAE,EAAEA,CAAC,EAAE,EAAE;YAC3B,MAAM5B,GAAE,GAAI,IAAIxB,GAAG,CACjBiD,cAAc,EACdC,eAAe,EACfC,UAAU,EACV9C,CAAC,CAACgD,KAAK,CAAC,WAAW,CACrB,CAAC;YACDL,SAAS,CAACM,IAAI,CAAC9B,GAAG,CAAC;UACrB;UACA+B,OAAO,CAACC,GAAG,CAAC,WAAW,EAAER,SAAS,CAAC;UACnC,OAAOA,SAAS;QAClB;QAEAzC,MAAM,CAACkD,QAAO,GAAI,YAAY;UAC5B;UACAnD,CAAA,GAAIC,MAAM,CAACC,UAAU;UACrBC,CAAA,GAAIF,MAAM,CAACG,WAAW;UACtBG,SAAQ,GAAIP,CAAA,GAAIK,IAAI;UACpBG,UAAS,GAAIL,CAAA,GAAIG,IAAI;UACrBP,CAAC,CAACqD,YAAY,CAACpD,CAAC,EAAEG,CAAC,CAAC;UACpBY,QAAQ,CAAC,CAAC;QACZ,CAAC;MACH,CAAC;MAED,IAAItB,EAAE,CAACK,MAAM,EAAE,YAAY,CAAC;IAC9B,CAAC,CAAC;EACJ;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}
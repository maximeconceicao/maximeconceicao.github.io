{"ast":null,"code":"export default class FlapText {\n  constructor(element, alphabet) {\n    this.element = element;\n    this.alphabet = alphabet;\n    this.currentPositions = [];\n    this.targetPositions = [];\n    this.randomPositions = [];\n  }\n\n  setInitialPositions(text) {\n    const textArray = text.split(\"\");\n    const textLength = textArray.length;\n    textArray.forEach((char, index) => {\n      const charIndex = this.alphabet.indexOf(char);\n\n      if (charIndex === -1) {\n        this.alphabet.push(char);\n        this.targetPositions[index] = this.alphabet.length - 1;\n      } else {\n        this.targetPositions[index] = charIndex;\n      }\n    }); //this.currentPositions = Array(textLength).fill(0);\n\n    this.currentPositions = this.targetPositions;\n    this.randomPositions = Array(textLength).fill(0);\n  }\n\n  resetCurrentPositions() {\n    for (let i = 0; i < this.currentPositions.length; i++) {\n      this.currentPositions[i] = this.targetPositions[i];\n    }\n\n    this.randomPositions.fill(0);\n  }\n\n  shufflePositions() {\n    const randomOffset = Math.floor(10 * Math.random()) + 5;\n\n    for (let i = 0; i < this.currentPositions.length; i++) {\n      this.currentPositions[i] = (this.currentPositions[i] + this.alphabet.length - randomOffset) % this.alphabet.length;\n      this.randomPositions[i] = Math.floor(10 * Math.random());\n    }\n  }\n\n  shiftRandomly(offset, multiplier) {\n    for (let i = 0; i < this.randomPositions.length; i++) {\n      this.randomPositions[i] = offset + i * multiplier;\n    }\n  }\n\n  flap() {\n    if (this.element.dataset.paused !== \"false\") {\n      return;\n    }\n\n    console.log(\"THIS RANDOM POSITIONS\", this.randomPositions);\n    this.currentPositions.forEach((position, index) => {\n      if (this.randomPositions[index] > 0) {\n        this.randomPositions[index]--;\n      } else if (this.currentPositions[index] !== this.targetPositions[index]) {\n        this.currentPositions[index] = (this.currentPositions[index] + 1) % this.alphabet.length;\n      }\n    });\n  }\n\n  render() {\n    console.log(\"RENDER\", this.currentPositions);\n    const newText = this.currentPositions.reduce((text, position) => {\n      let char = this.alphabet[position];\n\n      if (char === \">\") {\n        char = \"&gt;\";\n      } else if (char === \"<\") {\n        char = \"&lt;\";\n      }\n\n      return text + char;\n    }, \"\");\n\n    if (this.element.innerHTML !== newText) {\n      this.element.innerHTML = newText;\n      console.log(\"NEW TEXT\", newText);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/maximeconceicao/personal_repos/sweet-portfolio/src/helpers/FlapText.js"],"names":["FlapText","constructor","element","alphabet","currentPositions","targetPositions","randomPositions","setInitialPositions","text","textArray","split","textLength","length","forEach","char","index","charIndex","indexOf","push","Array","fill","resetCurrentPositions","i","shufflePositions","randomOffset","Math","floor","random","shiftRandomly","offset","multiplier","flap","dataset","paused","console","log","position","render","newText","reduce","innerHTML"],"mappings":"AAAA,eAAe,MAAMA,QAAN,CAAe;AAC5BC,EAAAA,WAAW,CAACC,OAAD,EAAUC,QAAV,EAAoB;AAC7B,SAAKD,OAAL,GAAeA,OAAf;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACA,SAAKC,eAAL,GAAuB,EAAvB;AACA,SAAKC,eAAL,GAAuB,EAAvB;AACD;;AAEDC,EAAAA,mBAAmB,CAACC,IAAD,EAAO;AACxB,UAAMC,SAAS,GAAGD,IAAI,CAACE,KAAL,CAAW,EAAX,CAAlB;AACA,UAAMC,UAAU,GAAGF,SAAS,CAACG,MAA7B;AACAH,IAAAA,SAAS,CAACI,OAAV,CAAkB,CAACC,IAAD,EAAOC,KAAP,KAAiB;AACjC,YAAMC,SAAS,GAAG,KAAKb,QAAL,CAAcc,OAAd,CAAsBH,IAAtB,CAAlB;;AACA,UAAIE,SAAS,KAAK,CAAC,CAAnB,EAAsB;AACpB,aAAKb,QAAL,CAAce,IAAd,CAAmBJ,IAAnB;AACA,aAAKT,eAAL,CAAqBU,KAArB,IAA8B,KAAKZ,QAAL,CAAcS,MAAd,GAAuB,CAArD;AACD,OAHD,MAGO;AACL,aAAKP,eAAL,CAAqBU,KAArB,IAA8BC,SAA9B;AACD;AACF,KARD,EAHwB,CAYxB;;AACA,SAAKZ,gBAAL,GAAwB,KAAKC,eAA7B;AACA,SAAKC,eAAL,GAAuBa,KAAK,CAACR,UAAD,CAAL,CAAkBS,IAAlB,CAAuB,CAAvB,CAAvB;AACD;;AAEDC,EAAAA,qBAAqB,GAAG;AACtB,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKlB,gBAAL,CAAsBQ,MAA1C,EAAkDU,CAAC,EAAnD,EAAuD;AACrD,WAAKlB,gBAAL,CAAsBkB,CAAtB,IAA2B,KAAKjB,eAAL,CAAqBiB,CAArB,CAA3B;AACD;;AACD,SAAKhB,eAAL,CAAqBc,IAArB,CAA0B,CAA1B;AACD;;AAEDG,EAAAA,gBAAgB,GAAG;AACjB,UAAMC,YAAY,GAAGC,IAAI,CAACC,KAAL,CAAW,KAAKD,IAAI,CAACE,MAAL,EAAhB,IAAiC,CAAtD;;AACA,SAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKlB,gBAAL,CAAsBQ,MAA1C,EAAkDU,CAAC,EAAnD,EAAuD;AACrD,WAAKlB,gBAAL,CAAsBkB,CAAtB,IACE,CAAC,KAAKlB,gBAAL,CAAsBkB,CAAtB,IAA2B,KAAKnB,QAAL,CAAcS,MAAzC,GAAkDY,YAAnD,IACA,KAAKrB,QAAL,CAAcS,MAFhB;AAGA,WAAKN,eAAL,CAAqBgB,CAArB,IAA0BG,IAAI,CAACC,KAAL,CAAW,KAAKD,IAAI,CAACE,MAAL,EAAhB,CAA1B;AACD;AACF;;AAEDC,EAAAA,aAAa,CAACC,MAAD,EAASC,UAAT,EAAqB;AAChC,SAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKhB,eAAL,CAAqBM,MAAzC,EAAiDU,CAAC,EAAlD,EAAsD;AACpD,WAAKhB,eAAL,CAAqBgB,CAArB,IAA0BO,MAAM,GAAGP,CAAC,GAAGQ,UAAvC;AACD;AACF;;AAEDC,EAAAA,IAAI,GAAG;AACL,QAAI,KAAK7B,OAAL,CAAa8B,OAAb,CAAqBC,MAArB,KAAgC,OAApC,EAA6C;AAC3C;AACD;;AAEDC,IAAAA,OAAO,CAACC,GAAR,CAAY,uBAAZ,EAAqC,KAAK7B,eAA1C;AACA,SAAKF,gBAAL,CAAsBS,OAAtB,CAA8B,CAACuB,QAAD,EAAWrB,KAAX,KAAqB;AACjD,UAAI,KAAKT,eAAL,CAAqBS,KAArB,IAA8B,CAAlC,EAAqC;AACnC,aAAKT,eAAL,CAAqBS,KAArB;AACD,OAFD,MAEO,IAAI,KAAKX,gBAAL,CAAsBW,KAAtB,MAAiC,KAAKV,eAAL,CAAqBU,KAArB,CAArC,EAAkE;AACvE,aAAKX,gBAAL,CAAsBW,KAAtB,IACE,CAAC,KAAKX,gBAAL,CAAsBW,KAAtB,IAA+B,CAAhC,IAAqC,KAAKZ,QAAL,CAAcS,MADrD;AAED;AACF,KAPD;AAQD;;AAEDyB,EAAAA,MAAM,GAAG;AACPH,IAAAA,OAAO,CAACC,GAAR,CAAY,QAAZ,EAAsB,KAAK/B,gBAA3B;AACA,UAAMkC,OAAO,GAAG,KAAKlC,gBAAL,CAAsBmC,MAAtB,CAA6B,CAAC/B,IAAD,EAAO4B,QAAP,KAAoB;AAC/D,UAAItB,IAAI,GAAG,KAAKX,QAAL,CAAciC,QAAd,CAAX;;AACA,UAAItB,IAAI,KAAK,GAAb,EAAkB;AAChBA,QAAAA,IAAI,GAAG,MAAP;AACD,OAFD,MAEO,IAAIA,IAAI,KAAK,GAAb,EAAkB;AACvBA,QAAAA,IAAI,GAAG,MAAP;AACD;;AACD,aAAON,IAAI,GAAGM,IAAd;AACD,KARe,EAQb,EARa,CAAhB;;AASA,QAAI,KAAKZ,OAAL,CAAasC,SAAb,KAA2BF,OAA/B,EAAwC;AACtC,WAAKpC,OAAL,CAAasC,SAAb,GAAyBF,OAAzB;AACAJ,MAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ,EAAwBG,OAAxB;AACD;AACF;;AAhF2B","sourcesContent":["export default class FlapText {\n  constructor(element, alphabet) {\n    this.element = element;\n    this.alphabet = alphabet;\n    this.currentPositions = [];\n    this.targetPositions = [];\n    this.randomPositions = [];\n  }\n\n  setInitialPositions(text) {\n    const textArray = text.split(\"\");\n    const textLength = textArray.length;\n    textArray.forEach((char, index) => {\n      const charIndex = this.alphabet.indexOf(char);\n      if (charIndex === -1) {\n        this.alphabet.push(char);\n        this.targetPositions[index] = this.alphabet.length - 1;\n      } else {\n        this.targetPositions[index] = charIndex;\n      }\n    });\n    //this.currentPositions = Array(textLength).fill(0);\n    this.currentPositions = this.targetPositions;\n    this.randomPositions = Array(textLength).fill(0);\n  }\n\n  resetCurrentPositions() {\n    for (let i = 0; i < this.currentPositions.length; i++) {\n      this.currentPositions[i] = this.targetPositions[i];\n    }\n    this.randomPositions.fill(0);\n  }\n\n  shufflePositions() {\n    const randomOffset = Math.floor(10 * Math.random()) + 5;\n    for (let i = 0; i < this.currentPositions.length; i++) {\n      this.currentPositions[i] =\n        (this.currentPositions[i] + this.alphabet.length - randomOffset) %\n        this.alphabet.length;\n      this.randomPositions[i] = Math.floor(10 * Math.random());\n    }\n  }\n\n  shiftRandomly(offset, multiplier) {\n    for (let i = 0; i < this.randomPositions.length; i++) {\n      this.randomPositions[i] = offset + i * multiplier;\n    }\n  }\n\n  flap() {\n    if (this.element.dataset.paused !== \"false\") {\n      return;\n    }\n\n    console.log(\"THIS RANDOM POSITIONS\", this.randomPositions);\n    this.currentPositions.forEach((position, index) => {\n      if (this.randomPositions[index] > 0) {\n        this.randomPositions[index]--;\n      } else if (this.currentPositions[index] !== this.targetPositions[index]) {\n        this.currentPositions[index] =\n          (this.currentPositions[index] + 1) % this.alphabet.length;\n      }\n    });\n  }\n\n  render() {\n    console.log(\"RENDER\", this.currentPositions);\n    const newText = this.currentPositions.reduce((text, position) => {\n      let char = this.alphabet[position];\n      if (char === \">\") {\n        char = \"&gt;\";\n      } else if (char === \"<\") {\n        char = \"&lt;\";\n      }\n      return text + char;\n    }, \"\");\n    if (this.element.innerHTML !== newText) {\n      this.element.innerHTML = newText;\n      console.log(\"NEW TEXT\", newText);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
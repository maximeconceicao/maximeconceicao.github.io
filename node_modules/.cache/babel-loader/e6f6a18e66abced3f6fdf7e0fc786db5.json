{"ast":null,"code":"export default class FlapText {\n  constructor(element, alphabet) {\n    this.element = element;\n    this.alphabet = alphabet;\n    this.currentPositions = [];\n    this.targetPositions = [];\n    this.randomPositions = [];\n  }\n\n  setInitialPositions(text) {\n    const textArray = text.split(\"\");\n    const textLength = textArray.length;\n    this.currentPositions = Array(textLength).fill(0);\n    textArray.forEach((char, index) => {\n      const charIndex = this.alphabet.indexOf(char);\n\n      if (charIndex === -1) {\n        this.alphabet.push(char);\n        this.targetPositions[index] = this.alphabet.length - 1;\n        this.currentPositions[index] = this.alphabet.length - 1;\n      } else {\n        this.targetPositions[index] = charIndex;\n        this.currentPositions[index] = charIndex;\n      }\n    });\n    this.randomPositions = Array(textLength).fill(0);\n    this.shufflePositions();\n  }\n\n  resetCurrentPositions() {\n    for (let i = 0; i < this.currentPositions.length; i++) {\n      this.currentPositions[i] = this.targetPositions[i];\n    }\n\n    this.randomPositions.fill(0);\n  }\n\n  shufflePositions() {\n    const randomOffset = Math.floor(10 * Math.random()) + 5;\n\n    for (let i = 0; i < this.currentPositions.length; i++) {\n      this.currentPositions[i] = (this.currentPositions[i] + this.alphabet.length - randomOffset) % this.alphabet.length;\n      this.randomPositions[i] = Math.floor(10 * Math.random());\n    }\n  }\n\n  flap() {\n    if (this.element.dataset.paused !== \"false\") {\n      return;\n    }\n\n    console.log(\"THIS RANDOM POSITIONS\", this.randomPositions);\n    this.currentPositions.forEach((position, index) => {\n      if (this.randomPositions[index] > 0) {\n        this.randomPositions[index]--;\n      } else if (this.currentPositions[index] !== this.targetPositions[index]) {\n        this.currentPositions[index] = (this.currentPositions[index] + 1) % this.alphabet.length;\n      }\n    });\n  }\n\n  render() {\n    console.log(\"RENDER\", this.currentPositions);\n    const newText = this.currentPositions.reduce((text, position) => {\n      let char = this.alphabet[position];\n\n      if (char === \">\") {\n        char = \"&gt;\";\n      } else if (char === \"<\") {\n        char = \"&lt;\";\n      }\n\n      return text + char;\n    }, \"\");\n\n    if (this.element.innerHTML !== newText) {\n      this.element.innerHTML = newText;\n      console.log(\"NEW TEXT\", newText);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/maximeconceicao/personal_repos/sweet-portfolio/src/helpers/FlapText.js"],"names":["FlapText","constructor","element","alphabet","currentPositions","targetPositions","randomPositions","setInitialPositions","text","textArray","split","textLength","length","Array","fill","forEach","char","index","charIndex","indexOf","push","shufflePositions","resetCurrentPositions","i","randomOffset","Math","floor","random","flap","dataset","paused","console","log","position","render","newText","reduce","innerHTML"],"mappings":"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","sourcesContent":["export default class FlapText {\n  constructor(element, alphabet) {\n    this.element = element;\n    this.alphabet = alphabet;\n    this.currentPositions = [];\n    this.targetPositions = [];\n    this.randomPositions = [];\n  }\n\n  setInitialPositions(text) {\n    const textArray = text.split(\"\");\n    const textLength = textArray.length;\n    this.currentPositions = Array(textLength).fill(0);\n\n    textArray.forEach((char, index) => {\n      const charIndex = this.alphabet.indexOf(char);\n      if (charIndex === -1) {\n        this.alphabet.push(char);\n        this.targetPositions[index] = this.alphabet.length - 1;\n        this.currentPositions[index] = this.alphabet.length - 1;\n      } else {\n        this.targetPositions[index] = charIndex;\n        this.currentPositions[index] = charIndex;\n      }\n    });\n    this.randomPositions = Array(textLength).fill(0);\n    this.shufflePositions();\n  }\n\n  resetCurrentPositions() {\n    for (let i = 0; i < this.currentPositions.length; i++) {\n      this.currentPositions[i] = this.targetPositions[i];\n    }\n    this.randomPositions.fill(0);\n  }\n\n  shufflePositions() {\n    const randomOffset = Math.floor(10 * Math.random()) + 5;\n    for (let i = 0; i < this.currentPositions.length; i++) {\n      this.currentPositions[i] =\n        (this.currentPositions[i] + this.alphabet.length - randomOffset) %\n        this.alphabet.length;\n      this.randomPositions[i] = Math.floor(10 * Math.random());\n    }\n  }\n\n  flap() {\n    if (this.element.dataset.paused !== \"false\") {\n      return;\n    }\n\n    console.log(\"THIS RANDOM POSITIONS\", this.randomPositions);\n    this.currentPositions.forEach((position, index) => {\n      if (this.randomPositions[index] > 0) {\n        this.randomPositions[index]--;\n      } else if (this.currentPositions[index] !== this.targetPositions[index]) {\n        this.currentPositions[index] =\n          (this.currentPositions[index] + 1) % this.alphabet.length;\n      }\n    });\n  }\n\n  render() {\n    console.log(\"RENDER\", this.currentPositions);\n    const newText = this.currentPositions.reduce((text, position) => {\n      let char = this.alphabet[position];\n      if (char === \">\") {\n        char = \"&gt;\";\n      } else if (char === \"<\") {\n        char = \"&lt;\";\n      }\n      return text + char;\n    }, \"\");\n    if (this.element.innerHTML !== newText) {\n      this.element.innerHTML = newText;\n      console.log(\"NEW TEXT\", newText);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"//import SimplexNoise from 'simplex-noise';\nimport utils from \"./utils\"; // Orb class\n\nexport default class Orb {\n  // Pixi takes hex colors as hexidecimal literals (0x rather than a string with '#')\n  constructor(fill = 0x000000) {\n    // bounds = the area an orb is \"allowed\" to move within\n    this.bounds = this.setBounds(); // initialise the orb's { x, y } values to autils.random point within it's bounds\n\n    this.x = utils.random(this.bounds[\"x\"].min, this.bounds[\"x\"].max);\n    this.y = utils.random(this.bounds[\"y\"].min, this.bounds[\"y\"].max); // how large the orb is vs it's original radius (this will modulate over time)\n\n    this.scale = 1; // what color is the orb?\n\n    this.fill = fill; // the original radius of the orb, set relative to window height\n\n    this.radius = utils.random(window.innerHeight / 6, window.innerHeight / 3); // starting points in \"time\" for the noise/self similar random values\n\n    this.xOff = utils.random(0, 1000);\n    this.yOff = utils.random(0, 1000); // how quickly the noise/self similar random values step through time\n\n    this.inc = 0.002; // PIXI.Graphics is used to draw 2d primitives (in this case a circle) to the canvas\n\n    this.graphics = new PIXI.Graphics();\n    this.graphics.alpha = 0.825; // 250ms after the last window resize event, recalculate orb positions.\n\n    window.addEventListener(\"resize\", debounce(() => {\n      this.bounds = this.setBounds();\n    }, 250));\n  }\n\n  setBounds() {\n    // how far from the { x, y } origin can each orb move\n    const maxDist = window.innerWidth < 1000 ? window.innerWidth / 3 : window.innerWidth / 5; // the { x, y } origin for each orb (the bottom right of the screen)\n\n    const originX = window.innerWidth / 1.25;\n    const originY = window.innerWidth < 1000 ? window.innerHeight : window.innerHeight / 1.375; // allow each orb to move x distance away from it's { x, y }origin\n\n    return {\n      x: {\n        min: originX - maxDist,\n        max: originX + maxDist\n      },\n      y: {\n        min: originY - maxDist,\n        max: originY + maxDist\n      }\n    };\n  }\n\n  update() {\n    // self similar \"psuedo-random\" or noise values at a given point in \"time\"\n    const xNoise = simplex.noise2D(this.xOff, this.xOff);\n    const yNoise = simplex.noise2D(this.yOff, this.yOff);\n    const scaleNoise = simplex.noise2D(this.xOff, this.yOff); // map the xNoise/yNoise values (between -1 and 1) to a point within the orb's bounds\n\n    this.x = map(xNoise, -1, 1, this.bounds[\"x\"].min, this.bounds[\"x\"].max);\n    this.y = map(yNoise, -1, 1, this.bounds[\"y\"].min, this.bounds[\"y\"].max); // map scaleNoise (between -1 and 1) to a scale value somewhere between half of the orb's original size, and 100% of it's original size\n\n    this.scale = map(scaleNoise, -1, 1, 0.5, 1); // step through \"time\"\n\n    this.xOff += this.inc;\n    this.yOff += this.inc;\n  }\n\n  render() {\n    // update the PIXI.Graphics position and scale values\n    this.graphics.x = this.x;\n    this.graphics.y = this.y;\n    this.graphics.scale.set(this.scale); // clear anything currently drawn to graphics\n\n    this.graphics.clear(); // tell graphics to fill any shapes drawn after this with the orb's fill color\n\n    this.graphics.beginFill(this.fill); // draw a circle at { 0, 0 } with it's size set by this.radius\n\n    this.graphics.drawCircle(0, 0, this.radius); // let graphics know we won't be filling in any more shapes\n\n    this.graphics.endFill();\n  }\n\n}","map":{"version":3,"sources":["/home/maxime/personal_repos/sweet-portfolio/src/helpers/Orb.js"],"names":["utils","Orb","constructor","fill","bounds","setBounds","x","random","min","max","y","scale","radius","window","innerHeight","xOff","yOff","inc","graphics","PIXI","Graphics","alpha","addEventListener","debounce","maxDist","innerWidth","originX","originY","update","xNoise","simplex","noise2D","yNoise","scaleNoise","map","render","set","clear","beginFill","drawCircle","endFill"],"mappings":"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","sourcesContent":["//import SimplexNoise from 'simplex-noise';\nimport utils from \"./utils\";\n\n// Orb class\nexport default class Orb {\n  // Pixi takes hex colors as hexidecimal literals (0x rather than a string with '#')\n  constructor(fill = 0x000000) {\n    // bounds = the area an orb is \"allowed\" to move within\n    this.bounds = this.setBounds();\n    // initialise the orb's { x, y } values to autils.random point within it's bounds\n    this.x = utils.random(this.bounds[\"x\"].min, this.bounds[\"x\"].max);\n    this.y = utils.random(this.bounds[\"y\"].min, this.bounds[\"y\"].max);\n\n    // how large the orb is vs it's original radius (this will modulate over time)\n    this.scale = 1;\n\n    // what color is the orb?\n    this.fill = fill;\n\n    // the original radius of the orb, set relative to window height\n    this.radius = utils.random(window.innerHeight / 6, window.innerHeight / 3);\n\n    // starting points in \"time\" for the noise/self similar random values\n    this.xOff = utils.random(0, 1000);\n    this.yOff = utils.random(0, 1000);\n    // how quickly the noise/self similar random values step through time\n    this.inc = 0.002;\n\n    // PIXI.Graphics is used to draw 2d primitives (in this case a circle) to the canvas\n    this.graphics = new PIXI.Graphics();\n    this.graphics.alpha = 0.825;\n\n    // 250ms after the last window resize event, recalculate orb positions.\n    window.addEventListener(\n      \"resize\",\n      debounce(() => {\n        this.bounds = this.setBounds();\n      }, 250)\n    );\n  }\n\n  setBounds() {\n    // how far from the { x, y } origin can each orb move\n    const maxDist =\n      window.innerWidth < 1000 ? window.innerWidth / 3 : window.innerWidth / 5;\n    // the { x, y } origin for each orb (the bottom right of the screen)\n    const originX = window.innerWidth / 1.25;\n    const originY =\n      window.innerWidth < 1000\n        ? window.innerHeight\n        : window.innerHeight / 1.375;\n\n    // allow each orb to move x distance away from it's { x, y }origin\n    return {\n      x: {\n        min: originX - maxDist,\n        max: originX + maxDist,\n      },\n      y: {\n        min: originY - maxDist,\n        max: originY + maxDist,\n      },\n    };\n  }\n\n  update() {\n    // self similar \"psuedo-random\" or noise values at a given point in \"time\"\n    const xNoise = simplex.noise2D(this.xOff, this.xOff);\n    const yNoise = simplex.noise2D(this.yOff, this.yOff);\n    const scaleNoise = simplex.noise2D(this.xOff, this.yOff);\n\n    // map the xNoise/yNoise values (between -1 and 1) to a point within the orb's bounds\n    this.x = map(xNoise, -1, 1, this.bounds[\"x\"].min, this.bounds[\"x\"].max);\n    this.y = map(yNoise, -1, 1, this.bounds[\"y\"].min, this.bounds[\"y\"].max);\n    // map scaleNoise (between -1 and 1) to a scale value somewhere between half of the orb's original size, and 100% of it's original size\n    this.scale = map(scaleNoise, -1, 1, 0.5, 1);\n\n    // step through \"time\"\n    this.xOff += this.inc;\n    this.yOff += this.inc;\n  }\n\n  render() {\n    // update the PIXI.Graphics position and scale values\n    this.graphics.x = this.x;\n    this.graphics.y = this.y;\n    this.graphics.scale.set(this.scale);\n\n    // clear anything currently drawn to graphics\n    this.graphics.clear();\n\n    // tell graphics to fill any shapes drawn after this with the orb's fill color\n    this.graphics.beginFill(this.fill);\n    // draw a circle at { 0, 0 } with it's size set by this.radius\n    this.graphics.drawCircle(0, 0, this.radius);\n    // let graphics know we won't be filling in any more shapes\n    this.graphics.endFill();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { createCommentVNode as _createCommentVNode, createTextVNode as _createTextVNode, createElementVNode as _createElementVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-3ee02572\"), n = n(), _popScopeId(), n);\n\nconst _hoisted_1 = /*#__PURE__*/_withScopeId(() => /*#__PURE__*/_createElementVNode(\"div\", {\n  class: \"flap\"\n}, [/*#__PURE__*/_createCommentVNode(\" Contenu de votre composant FlapText \"), /*#__PURE__*/_createTextVNode(\" Phrase test pour flap text ! \")], -1\n/* HOISTED */\n));\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(_Fragment, null, [_createCommentVNode(\" Vous pouvez ajouter le HTML associé ici si nécessaire \"), _hoisted_1], 2112\n  /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */\n  );\n}","map":{"version":3,"mappings":";;;;gEAEEA,oBAGM,KAHN,EAGM;AAHDC,OAAK,EAAC;AAGL,CAHN,EAAiB,cACfC,4DADe,gCAC6B,iCAD7B,CAAjB;;AAAA;;;6DADAA,gFACAC","names":["_createElementVNode","class","_createCommentVNode","_hoisted_1"],"sourceRoot":"","sources":["/Users/maximeconceicao/personal_repos/sweet-portfolio/src/components/FlapText.vue"],"sourcesContent":["<template>\n  <!-- Vous pouvez ajouter le HTML associé ici si nécessaire -->\n  <div class=\"flap\">\n    <!-- Contenu de votre composant FlapText -->\n    Phrase test pour flap text !\n  </div>\n</template>\n\n<script>\nconst characters =\n  \"\\\"'“”‘’¹²³!#$&%()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~½¼¡«»×▓▒░│┤▀└┴┬├─┼┐┌└┘\".split(\n    \"\"\n  );\nclass FlapText {\n  constructor(element, alphabet) {\n    this.element = element;\n    this.alphabet = alphabet;\n    this.currentPositions = [];\n    this.targetPositions = [];\n    this.randomPositions = [];\n  }\n\n  setInitialPositions(text) {\n    const textArray = text.split(\"\");\n    const textLength = textArray.length;\n    textArray.forEach((char, index) => {\n      const charIndex = this.alphabet.indexOf(char);\n      if (charIndex === -1) {\n        this.alphabet.push(char);\n        this.targetPositions[index] = this.alphabet.length - 1;\n      } else {\n        this.targetPositions[index] = charIndex;\n      }\n    });\n    this.currentPositions = Array(textLength).fill(0);\n    this.randomPositions = Array(textLength).fill(0);\n  }\n\n  resetCurrentPositions() {\n    for (let i = 0; i < this.currentPositions.length; i++) {\n      this.currentPositions[i] = this.targetPositions[i];\n    }\n    this.randomPositions.fill(0);\n  }\n\n  shufflePositions() {\n    const randomOffset = Math.floor(10 * Math.random()) + 5;\n    for (let i = 0; i < this.currentPositions.length; i++) {\n      this.currentPositions[i] =\n        (this.currentPositions[i] + this.alphabet.length - randomOffset) %\n        this.alphabet.length;\n      this.randomPositions[i] = Math.floor(10 * Math.random());\n    }\n  }\n\n  shiftRandomly(offset, multiplier) {\n    for (let i = 0; i < this.randomPositions.length; i++) {\n      this.randomPositions[i] = offset + i * multiplier;\n    }\n  }\n\n  flap() {\n    if (this.element.dataset.paused !== \"false\") {\n      return;\n    }\n    this.currentPositions.forEach((position, index) => {\n      if (this.randomPositions[index] > 0) {\n        this.randomPositions[index]--;\n      } else if (this.currentPositions[index] !== this.targetPositions[index]) {\n        this.currentPositions[index] =\n          (this.currentPositions[index] + 1) % this.alphabet.length;\n      }\n    });\n  }\n\n  render() {\n    const newText = this.currentPositions.reduce((text, position) => {\n      let char = this.alphabet[this.currentPositions[position]];\n      if (char === \">\") {\n        char = \"&gt;\";\n      } else if (char === \"<\") {\n        char = \"&lt;\";\n      }\n      return text + char;\n    }, \"\");\n    if (this.element.innerHTML !== newText) {\n      this.element.innerHTML = newText;\n    }\n  }\n}\n\n(function () {\n  const flapTextElements = [];\n  let textIndex = 0;\n\n  document.querySelectorAll(\".flap\").forEach((flapElement) => {\n    const lines = flapElement.innerText\n      .trimEnd()\n      .split(\"\\n\")\n      .map((line) => line.trimEnd().replaceAll(\"\\t\", \"\"));\n    flapElement.innerHTML = \"\";\n    if (flapElement.dataset.offset === \"0\") {\n      textIndex = 0;\n    }\n    lines.forEach((line) => {\n      const span = (function (parent, elementType, attributes) {\n        const element = document.createElement(elementType);\n        for (const attr in attributes) {\n          element[attr] = attributes[attr];\n        }\n        parent.appendChild(element);\n        return element;\n      })(flapElement, \"SPAN\", { dataset: { paused: \"true\" } });\n      new IntersectionObserver(\n        (entries) => {\n          if (entries[0].isIntersecting === true) {\n            span.dataset.paused = \"false\";\n          }\n        },\n        { threshold: [0] }\n      ).observe(span);\n\n      const flapText = new FlapText(span, characters);\n      flapText.setInitialPositions(line);\n      flapText.render();\n      flapText.shiftRandomly(5 * textIndex++, 1);\n\n      span.addEventListener(\"mouseenter\", () => {\n        flapText.shufflePositions();\n      });\n\n      flapTextElements.push(flapText);\n    });\n  });\n\n  let frameCount = 0;\n  requestAnimationFrame(function animate() {\n    requestAnimationFrame(animate);\n    if (frameCount++ % 2 === 0) {\n      for (const flapText of flapTextElements) {\n        flapText.flap();\n        flapText.render();\n      }\n    }\n  });\n\n  document.querySelectorAll(\".flap\").forEach((flapElement) => {\n    flapElement.classList.remove(\"hidden\");\n  });\n})();\n</script>\n\n<style scoped>\n/* Styles spécifiques au composant ici, ou utilisez des classes externes */\n</style>\n"]},"metadata":{},"sourceType":"module"}